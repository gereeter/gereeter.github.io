<!DOCTYPE html>
<head>
<meta charset="utf-8">
<meta name="color-scheme" content="light dark">
<title>Isomorphic Hex Keyboard</title>
<script>
// UI state
let audioContext = null;
const notes = new Map();
const visualElements = new Map();

// Global settings; these are set via the update* functions and their default values are specified in the forms
let tuning = {
    basePitch: null,
    ratios: null, // we support any regular diatonic tuning system
};
let voicing = {
    wave: null,
    gains: null,
    activeDecayTime: null,
};
let effects = {
    randomVolumeAmount: null,
};

// Pedals
let sustain = false;


///// Core audio functionality /////

function startNote(w, h, soft) {
    // Lazily initialize the audio context; we don't need it until we start playing audio, and autoplay protection will
    // cause warnings otherwise.
    if (audioContext === null) {
        audioContext = new AudioContext();
    }

    // Create the note if it doesn't exist
    if (!notes.has(h)) {
        notes.set(h, new Map());
    }
    const row = notes.get(h);
    if (!row.has(w)) {
        row.set(w, { active: [], inactive: [], held: false });
    }
    const note = row.get(w);

    // Cleanup complete sounds
    const time = audioContext.currentTime;
    note.inactive = note.inactive.filter(function(sound) {
        if (sound.endTime <= time) {
            for (const gain of sound.gains) {
                gain.disconnect();
            }
            for (const oscillator of sound.oscillators) {
                oscillator.disconnect();
            }
            return false;
        } else {
            return true;
        }
    });

    if (note.held) {
        // This is hopefully caught by filtering on event.repeat, but that's not reliable.
        return;
    } else {
        note.held = true;
    }

    // Light up the key visually
    if (visualElements.has(h)) {
        const visualRow = visualElements.get(h);
        if (visualRow.has(w)) {
            const visual = visualRow.get(w);
            visual.classList.add("active");
        }
    }

    // Make sure our globals are up to date
    updateTunings();
    updateVoicings();
    updateEffects();

    // Finally, build the sound!
    const sound = {
        startTime: time,
        endTime: 0,
        volume: soft ? 0.06 : 0.2,
        oscillators: [],
        gains: [],
    };
    if (effects.randomVolumeAmount > 0) {
        // Modulate by a triangular distribution in log space
        sound.volume *= Math.exp((Math.random() - Math.random()) * effects.randomVolumeAmount);
    }
    for (let i = 0; i < voicing.gains.length; i++) {
        const harmonic = i + 1;

        const oscillatorSettings = { frequency: tuning.basePitch * Math.pow(tuning.ratios.whole, w) * Math.pow(tuning.ratios.half, h) * harmonic };
        if (voicing.wave instanceof PeriodicWave) {
            oscillatorSettings.periodicWave = voicing.wave;
        } else {
            oscillatorSettings.type = voicing.wave;
        }
        const oscillator = new OscillatorNode(audioContext, oscillatorSettings);

        // TODO: ramp?
        /*if (current < 0.2 * volume) {
            gainNode.gain.linearRampToValueAtTime(0.2 * volume, time + 0.05);
        }
        gainNode.gain.linearRampToValueAtTime(current + volume, time + 0.1);
        gainNode.gain.linearRampToValueAtTime(Math.max(current, volume), time + 0.15);*/
        const gain = new GainNode(audioContext, { gain: 0 });
        gain.gain.setValueAtTime(sound.volume * voicing.gains[i], sound.startTime);
        if (Number.isFinite(voicing.activeDecayTime)) {
            gain.gain.setTargetAtTime(0, sound.startTime, voicing.activeDecayTime / harmonic);
        }

        sound.oscillators.push(oscillator);
        sound.gains.push(gain);

        oscillator.connect(gain);
        gain.connect(audioContext.destination);
        oscillator.start(sound.startTime);
    }
    note.active.push(sound);
}

function endNote(w, h) {
    if (!notes.has(h)) { return; }
    const row = notes.get(h);
    if (!row.has(w)) { return; }
    const note = row.get(w);
    note.held = false;
    if (visualElements.has(h)) {
        const visualRow = visualElements.get(h);
        if (visualRow.has(w)) {
            const visual = visualRow.get(w);
            visual.classList.remove("active");
        }
    }

    if (sustain) {
        return;
    }

    const time = audioContext.currentTime;
    for (const sound of note.active) {
        sound.endTime = time + 0.25;
        for (const gain of sound.gains) {
            const current = gain.gain.value;
            gain.gain.cancelScheduledValues(time);
            gain.gain.setValueAtTime(current, time);
            gain.gain.linearRampToValueAtTime(0, sound.endTime);
        }
        for (const oscillator of sound.oscillators) {
            oscillator.stop(sound.endTime);
        }
        note.inactive.push(sound);
    }
    note.active = [];
}

function startSustain() {
    sustain = true;
}

function endSustain() {
    if (sustain) {
        sustain = false;
        for (const [h, row] of notes) {
            for (const [w, note] of row) {
                if (!note.held) {
                    endNote(w, h);
                }
            }
        }
    }
}

function endAll() {
    sustain = false;
    for (const row of notes.values()) {
        for (const note of row.values()) {
            for (const sound of note.active.concat(note.inactive)) {
                for (const gain of sound.gains) {
                    gain.gain.setValueAtTime(0, 0);
                    gain.disconnect();
                }
                for (const oscillator of sound.oscillators) {
                    oscillator.stop();
                    oscillator.disconnect();
                }
            }
        }
    }
    notes.clear();
    for (const visualRow of visualElements.values()) {
        for (const visual of visualRow.values()) {
            visual.classList.remove("active");
        }
    }
}


///// Keyboard Interface /////

const keyMapping = new Map([
    ["Backquote",    { w: -7, h: -2 }],
    ["Digit1",       { w: -6, h: -2 }],
    ["Digit2",       { w: -5, h: -2 }],
    ["Digit3",       { w: -4, h: -2 }],
    ["Digit4",       { w: -3, h: -2 }],
    ["Digit5",       { w: -2, h: -2 }],
    ["Digit6",       { w: -1, h: -2 }],
    ["Digit7",       { w:  0, h: -2 }],
    ["Digit8",       { w:  1, h: -2 }],
    ["Digit9",       { w:  2, h: -2 }],
    ["Digit0",       { w:  3, h: -2 }],
    ["Minus",        { w:  4, h: -2 }],
    ["Equal",        { w:  5, h: -2 }],
    ["KeyQ",         { w: -6, h: -1 }],
    ["KeyW",         { w: -5, h: -1 }],
    ["KeyE",         { w: -4, h: -1 }],
    ["KeyR",         { w: -3, h: -1 }],
    ["KeyT",         { w: -2, h: -1 }],
    ["KeyY",         { w: -1, h: -1 }],
    ["KeyU",         { w:  0, h: -1 }],
    ["KeyI",         { w:  1, h: -1 }],
    ["KeyO",         { w:  2, h: -1 }],
    ["KeyP",         { w:  3, h: -1 }],
    ["BracketLeft",  { w:  4, h: -1 }],
    ["BracketRight", { w:  5, h: -1 }],
    ["KeyA",         { w: -6, h:  0 }],
    ["KeyS",         { w: -5, h:  0 }],
    ["KeyD",         { w: -4, h:  0 }],
    ["KeyF",         { w: -3, h:  0 }],
    ["KeyG",         { w: -2, h:  0 }],
    ["KeyH",         { w: -1, h:  0 }],
    ["KeyJ",         { w:  0, h:  0 }],
    ["KeyK",         { w:  1, h:  0 }],
    ["KeyL",         { w:  2, h:  0 }],
    ["Semicolon",    { w:  3, h:  0 }],
    ["Quote",        { w:  4, h:  0 }],
    ["KeyZ",         { w: -6, h:  1 }],
    ["KeyX",         { w: -5, h:  1 }],
    ["KeyC",         { w: -4, h:  1 }],
    ["KeyV",         { w: -3, h:  1 }],
    ["KeyB",         { w: -2, h:  1 }],
    ["KeyN",         { w: -1, h:  1 }],
    ["KeyM",         { w:  0, h:  1 }],
    ["Comma",        { w:  1, h:  1 }],
    ["Period",       { w:  2, h:  1 }],
    ["Slash",        { w:  3, h:  1 }],
]);

window.addEventListener("keydown", function(event) {
    if (event.key === "Escape") {
        endAll();
        return;
    }

    if (event.ctrlKey || event.altKey || event.metaKey) { return; }
    if (event.target.nodeName === "INPUT" && event.target.type === "number") { return; }

    if (event.key === " ") {
        startSustain();
    } else if (keyMapping.has(event.code)) {
        const position = keyMapping.get(event.code);
        if (!event.repeat) {
            startNote(position.w, position.h, event.shiftKey);
        }
    } else {
        return;
    }

    event.preventDefault();
});
window.addEventListener("keyup", function(event) {
    if (event.key === " ") {
        endSustain();
    } else if (keyMapping.has(event.code)) {
        const position = keyMapping.get(event.code);
        
        endNote(position.w, position.h);
    }
});


///// Spatial/Visual Interface /////

function handleMousePress(event) {
    if (event.buttons === 1) {
        startNote(+event.target.dataset.w, +event.target.dataset.h, event.shiftKey);
    }
}

function handleMouseRelease(event) {
    endNote(+event.target.dataset.w, +event.target.dataset.h);
}

function handleMouseLeave(event) {
    if ((event.buttons & 1) !== 0) {
        handleMouseRelease(event);
    }
}

function handleTouchPress(event) {
    event.preventDefault();
    startNote(+event.target.dataset.w, +event.target.dataset.h, event.shiftKey);
}

function handleTouchRelease(event) {
    endNote(+event.target.dataset.w, +event.target.dataset.h);
}

// Unfortunately, there isn't an equivalent of mouseenter/mouseleave for touch events. Therefore, simulate it
// by tracking touches across the whole window and keeping track of where they currently are.
const touchLocations = new Map();
function stopTrackingTouch(event) {
    for (const touch of event.changedTouches) {
        let previous;
        if (touchLocations.has(touch.identifier)) {
            previous = touchLocations.get(touch.identifier);
            touchLocations.delete(touch.identifier);
        } else {
            previous = touch.target;
        }
        previous.dispatchEvent(new Event("_touchleaveend"));
    }
}
window.addEventListener("touchend", stopTrackingTouch, { passive: true });
window.addEventListener("touchcancel", stopTrackingTouch, { passive: true });
window.addEventListener("touchmove", function(event) {
    for (const touch of event.changedTouches) {
        const current = document.elementFromPoint(touch.clientX, touch.clientY);

        if (!touchLocations.has(touch.identifier)) {
            touchLocations.set(touch.identifier, touch.target);
        }

        const previous = touchLocations.get(touch.identifier);
        touchLocations.set(touch.identifier, current);

        if (previous !== current) {
            previous.dispatchEvent(new Event("_touchleaveend"));
            current.dispatchEvent(new Event("_touchenter"));
        }
    }
}, { passive: true });

function updateKeyboard() {
    visualElements.clear();
    // There are approximately `scale` keys horizontally across the page
    const scale = Math.pow(2, -document.getElementById("keysize").valueAsNumber);
    const labelMode = new FormData(document.getElementById("keyboardForm")).get("labelMode");

    const svgNs = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNs, "svg");
    const aspectRatio = document.documentElement.clientHeight / document.documentElement.clientWidth;
    // Each key has radius 1
    svg.setAttribute("viewBox", "" + (-scale) + " " + (-aspectRatio*scale) + " " + (2*scale) + " " + (2*scale*aspectRatio));
    svg.setAttribute("width", "100%");

    // Vectors between the keys in each direction. Note that these are half of the way from key to key, as
    // they have unit magnitude. This tilt is chosen so that octaves are perfectly horizontal.
    const sqrt3 = Math.sqrt(3);
    const invSqrt13 = 1 / Math.sqrt(13);
    const wholeX = 2 * sqrt3 * invSqrt13;
    const wholeY = -invSqrt13;
    const halfX = 1.5 * sqrt3 * invSqrt13;
    const halfY = 2.5 * invSqrt13;

    // The corners of a hexagon, relative to its center.
    const hexScale = 1;
    const hexX1 = -wholeY * hexScale;
    const hexY1 = wholeX * hexScale;
    const hexX2 = -halfY * hexScale;
    const hexY2 = halfX * hexScale;
    const hexX3 = (wholeY - halfY) * hexScale;
    const hexY3 = (halfX - wholeX) * hexScale;
    
    // We want the center to be in between -2,0 and -1,-1 (i.e. in the middle of the C major scale), and then to render
    // every hexagon potentially within the box. To do this we measure the Euclidean distance to the corner, then scale it
    // up to an upper bound on hexagonal taxicab distance.
    const radiusBound = Math.floor(Math.hypot(1, aspectRatio) * scale * 2 / sqrt3);

    // Hexagonal distance is computed based on the maximum distance in each possible direction:
    //   wDist = w * 2 + 3;
    //   hDist = h * 2 + 1;
    //   whDist = wDist + hDist;
    //   max(wDist, -wDist, hDist, -hDist, whDist, -whDist) <= radiusBound
    const wMin = Math.ceil((-radiusBound - 3) / 2);
    const wMax = Math.floor((radiusBound - 3) / 2);
    for (let w = wMin; w <= wMax; w++) {
        const wDist = w * 2 + 3;
        const hMin = Math.ceil((-radiusBound - 1 - Math.min(0, wDist)) / 2);
        const hMax = Math.floor((radiusBound - 1 - Math.max(0, wDist)) / 2);
        for (let h = hMin; h <= hMax; h++) {
            const hDist = h * 2 + 1;
            const centerX = wholeX * wDist + halfX * hDist;
            const centerY = wholeY * wDist + halfY * hDist;

            // Check to ensure the axis-aligned square our hexagon is inscribed in is fully in frame. (Cheaper
            // than computing an exact intersection and practically as good.)
            if (Math.abs(centerX) + 1 <= scale && Math.abs(centerY) + 1 <= scale * aspectRatio) {
                const polygon = document.createElementNS(svgNs, "polygon");
                polygon.setAttribute("points",
                       "" + (centerX + hexX1) + " " + (centerY + hexY1)
                    + " " + (centerX + hexX2) + " " + (centerY + hexY2)
                    + " " + (centerX + hexX3) + " " + (centerY + hexY3)
                    + " " + (centerX - hexX1) + " " + (centerY - hexY1)
                    + " " + (centerX - hexX2) + " " + (centerY - hexY2)
                    + " " + (centerX - hexX3) + " " + (centerY - hexY3)
                );
                polygon.classList.add("hex");
                polygon.dataset.w = w;
                polygon.dataset.h = h;
                polygon.addEventListener("mousedown", handleMousePress, { passive: true });
                polygon.addEventListener("mouseenter", handleMousePress, { passive: true });
                polygon.addEventListener("touchstart", handleTouchPress);
                polygon.addEventListener("_touchenter", handleTouchPress, { passive: true });
                polygon.addEventListener("mouseup", handleMouseRelease, { passive: true });
                polygon.addEventListener("mouseleave", handleMouseLeave, { passive: true });
                polygon.addEventListener("_touchleaveend", handleTouchRelease, { passive: true });
                svg.appendChild(polygon);

                // Display our 0, 0 point (A440) specially.
                if (w === 0 && h === 0) {
                    polygon.classList.add("a440");
                }

                // Label the standard scale
                if (labelMode !== "none") {
                    const octave = Math.floor((w + h + 5) / 7) + 4;
                    const note = Math.floor((((w + h) % 7) + 7) % 7);
                    const expectedHalf = (octave - 4) * 2 - (2 <= note && note <= 4 ? 1 : 0);
                    let accidental = null;
                    if (expectedHalf === h) {
                        accidental = "";
                    } else if (labelMode === "accidentals" && expectedHalf === h + 1 && note !== 1 && note !== 4) {
                        accidental = "♯";
                    } else if (labelMode === "accidentals" && expectedHalf === h - 1 && note !== 2 && note !== 5) {
                        accidental = "♭";
                    }

                    if (accidental !== null) {
                        const text = document.createElementNS(svgNs, "text");
                        text.setAttribute("x", centerX);
                        text.setAttribute("y", centerY);
                        text.setAttribute("dy", "0.5cap");
                        text.appendChild(document.createTextNode(String.fromCharCode(note+65) + accidental + octave));
                        if (accidental !== "") {
                            text.classList.add("accidental");
                        }
                        svg.appendChild(text);
                    }
                }

                // And set ourselves up to be lit up when playing notes
                if (!visualElements.has(h)) {
                    visualElements.set(h, new Map());
                }
                const visualRow = visualElements.get(h);
                visualRow.set(w, polygon);

                // It's possible that the keyboard is being updated while notes are being played.
                if (notes.has(h)) {
                    const row = notes.get(h);
                    if (row.has(w)) {
                        const note = row.get(w);
                        if (note.held) {
                            polygon.classList.add("active");
                        }
                    }
                }
            }
        }
    }

    const container = document.getElementById("keyboard");
    container.replaceChildren(svg);
}

document.addEventListener("DOMContentLoaded", updateKeyboard);
window.addEventListener("resize", updateKeyboard);


///// Keep the tuning form state synced with itself and the values being played. /////

function tuningEDO(divisions, wholeStep, halfStep) {
    return {
        whole: Math.pow(2, wholeStep / divisions),
        half: Math.pow(2, halfStep / divisions),
    };
}

// Finds Ratios assuming constant fifths and just octaves
function tuningFromFifth(fifth) {
    const fifth2 = fifth * fifth;
    return {
        whole: fifth2 / 2, // 2 fifths = 1 octave + 1 whole step
        half: 8 / (fifth2 * fifth2 * fifth), // 5 fifths + 1 half step = 3 octaves
    };
}

const tuningMapping = new Map([
    // Notable equal divisions of the octave
    ["12-equal", tuningEDO(12, 2, 1)],
    ["17-equal", tuningEDO(17, 3, 1)],
    ["19-equal", tuningEDO(19, 3, 2)],
    ["22-equal", tuningEDO(22, 4, 1)],
    ["31-equal", tuningEDO(31, 5, 3)],
    ["43-equal", tuningEDO(43, 7, 4)],
    ["53-equal", tuningEDO(53, 9, 4)],
    // Tunings based on peaks of the Riemann zeta function
    // Values taken from https://en.xen.wiki/w/The_Riemann_zeta_function_and_tuning#Zeta_edo_lists
    ["12-zeta", tuningEDO(12.02318, 2, 1)],
    ["19-zeta", tuningEDO(18.94809, 3, 2)],
    ["22-zeta", tuningEDO(22.02515, 4, 1)],
    ["31-zeta", tuningEDO(30.97838, 5, 3)],
    ["41-zeta", tuningEDO(40.98808, 7, 3)],
    ["53-zeta", tuningEDO(52.99683, 9, 4)],
    // Meantones and direct attempts at just intonation
    ["pythagorean", tuningFromFifth(3 / 2)],
    ["quarter-comma", tuningFromFifth(Math.pow(5, 1 / 4))],
    ["septimal", tuningFromFifth(Math.pow(56, 1 / 10))],
    // The choice that minimizes the maximum error of
    // - just fifths (frequency ratio 3/2) from 3 whole + 1 half
    // - just major thirds (frequency ratio 5/4) from 2 whole
    // Under the constraint that there are
    // - exact just octaves (frequency ratio 2) from 5 whole + 2 half
    // The maximum error is a fifth of syntonic comma.
    ["minimax", { whole: Math.pow(225/128, 1/5), half: 16/15 }],
    // The choice that minimizes the maximum error of
    // - just fifths (frequency ratio 3/2) from 3 whole + 1 half
    // - just major thirds (frequency ratio 5/4) from 2 whole
    // - just octaves (frequency ratio 2)
    // The maximum error is a seventh of a syntonic comma.
    ["minimax3", { whole: Math.pow(1125/512, 1/7), half: 1.6 * Math.pow(8 / 135, 1/7) }],
    ["squished", { whole: 0.5 * Math.sqrt(5), half: 0.48 * Math.sqrt(5) }],
]);

function updateTunings() {
    // We'll be called again in startNote.
    if (audioContext === null) { return; }

    const tuningName = new FormData(document.getElementById("tuningForm")).get("tuning");
    switch (tuningName) {
    case "custom-equal":
        const divisions = document.getElementById("equalDivisions").valueAsNumber;
        const equalWhole = document.getElementById("equalWholeStep").valueAsNumber;
        const equalHalf = document.getElementById("equalHalfStep").valueAsNumber;
        if (equalWhole >= 1 && equalHalf >= 1) {
            tuning.ratios = tuningEDO(divisions, equalWhole, equalHalf);
        }
        break;
    case "custom":
        const customWRatio = document.getElementById("wholeStep").valueAsNumber;
        const customHRatio = document.getElementById("halfStep").valueAsNumber;
        if (customWRatio >= 1 && customHRatio >= 1) {
            tuning.ratios = { whole: customWRatio, half: customHRatio };
        }
        break;
    default:
        if (tuningMapping.has(tuningName)) {
            tuning.ratios = tuningMapping.get(tuningName);
        }
        break;
    }
    
    const customBasePitch = document.getElementById("basePitch").valueAsNumber;
    if (customBasePitch >= 1) {
        tuning.basePitch = customBasePitch;
    }

    const currentTime = audioContext.currentTime;
    for (const [h, row] of notes) {
        for (const [w, note] of row) {
            const rootFrequency = tuning.basePitch * Math.pow(tuning.ratios.whole, w) * Math.pow(tuning.ratios.half, h);
            for (const sound of note.active) {
                for (let i = 0; i < sound.oscillators.length; i++) {
                    const harmonic = i + 1;
                    sound.oscillators[i].frequency.setValueAtTime(rootFrequency * harmonic, currentTime);
                }
            }
        }
    }
}

function voicingFromWave(wave) {
    return {
        wave: wave,
        gains: new Float32Array([1]),
        activeDecayTime: Number.POSITIVE_INFINITY,
    };
}

function updateVoicings() {
    // We need the context to generate a PeriodicWave, and we'll be called again in startNote.
    if (audioContext === null) { return; }

    const formData = new FormData(document.getElementById("voicingForm"));

    const voicingName = formData.get("voicing");
    switch (voicingName) {
    case "sine":
    case "square":
    case "sawtooth":
    case "triangle":
        voicing = voicingFromWave(voicingName);
        break;
    // These Fourier series are roughly approximated by hand and don't sound very good. They could do with a lot of
    // tweaking, even before accounting for things like noticeable attacks and variation in overtones with pitch.
    case "piano":
        voicing = voicingFromWave(new PeriodicWave(audioContext, { real: new Float32Array([0, 1, 0.1, 0.33, 0.6, 0.4]) }));
        break;
    case "oboe":
        voicing = voicingFromWave(new PeriodicWave(audioContext, { real: new Float32Array([0, 1, 0.95, 2.1, 0.17, 0.19, 0.22, 0.55, 0.3, 0.2]) }));
        break;
    case "clarinet":
        voicing = voicingFromWave(new PeriodicWave(audioContext, { real: new Float32Array([0, 1, 0.36, 0.26, 0.01, 0.08, 0.2, 0.03]) }));
        break;
    case "horn":
        voicing = voicingFromWave(new PeriodicWave(audioContext, { real: new Float32Array([0, 1, 0.39, 0.23, 0.21, 0.75, 0.57, 0.7, 0.53, 0.5, 0.28, 0.1, 0.06, 0.07]) }));
        break;
    case "custom-string":
        const location = document.getElementById("stringLocation").valueAsNumber;
        const decay = document.getElementById("stringDecay").valueAsNumber;

        // TODO: make this configurable?
        const fourierCount = 20;
        voicing = {
            wave: "sine",
            gains: new Float32Array(fourierCount),
            activeDecayTime: -Math.log2(1 - decay),
        };

        // Compute the Fourier series of an asymmetric triangle wave. Since the vibrational modes of a string are
        // physically sine waves, the amount of vibration in each mode corresponds exactly to the Fourier decomposition
        // of the physical shape of the string. In a plucking configuration, this is a triangle.
        const locationMin = Math.min(location, 1 - location);
        for (let i = 0; i < fourierCount; i++) {
            let harmonic = i + 1;
            if (locationMin < 0.01) {
                // Divide everything by locationMin * Math.PI symbolically to avoid dividing by near zero
                // sin(l * h * pi) / h^2 = sinc(l * h * pi) * l * pi / h
                // sinc(l * h * pi) / h
                // ~= 1 / h - (l^2 * h * pi^2) / 6
                // Note: above is the mathematical unnormalized sinc, not the signal processing normalized sinc
                voicing.gains[i] = 1 / harmonic - harmonic * ((locationMin * locationMin) * (Math.PI * Math.PI / 6));
            } else {
                voicing.gains[i] = Math.sin(locationMin * harmonic * Math.PI) / (harmonic * harmonic);
            }
        }

        // Normalize the coefficients. We could compute the analytical solution, but this is fast and accounts for
        // the error of not using the full Fourier series.
        let totalCoeff = 0;
        for (let i = 0; i < fourierCount; i++) {
            totalCoeff += Math.abs(voicing.gains[i]);
        }
        const normalize = 1 / totalCoeff;
        for (let i = 0; i < fourierCount; i++) {
            voicing.gains[i] *= normalize;
        }

        break;
    }

    const currentTime = audioContext.currentTime;
    for (const [h, row] of notes) {
        for (const [w, note] of row) {
            for (const sound of note.active) {
                for (let i = voicing.gains.length; i < sound.gains.length; i++) {
                    sound.gains[i].gain.setValueAtTime(0, currentTime);
                }
                for (let i = 0; i < Math.min(voicing.gains.length, sound.oscillators.length); i++) {
                    const harmonic = i + 1;
                    if (voicing.wave instanceof PeriodicWave) {
                        sound.oscillators[i].setPeriodicWave(voicing.wave);
                    } else if (sound.oscillators[i].type !== voicing.wave) {
                        sound.oscillators[i].type = voicing.wave;
                    }
                    sound.gains[i].gain.cancelScheduledValues(currentTime);
                    if (Number.isFinite(voicing.activeDecayTime)) {
                        sound.gains[i].gain.setValueAtTime(sound.volume * voicing.gains[i] * Math.exp(harmonic * (sound.startTime - currentTime) / voicing.activeDecayTime), currentTime);
                        sound.gains[i].gain.setTargetAtTime(0, currentTime, voicing.activeDecayTime / harmonic);
                    } else {
                        sound.gains[i].gain.setValueAtTime(sound.volume * voicing.gains[i], currentTime);
                    }
                }
            }
        }
    }
}

function updateEffects() {
    const doRandomizeVolume = document.getElementById("randomVolume").checked;
    if (doRandomizeVolume) {
        effects.randomVolumeAmount = document.getElementById("randomVolumeAmount").valueAsNumber;
    } else {
        effects.randomVolumeAmount = 0;
    }
}

// The custom equal division assumes that 5 whole + 2 half makes up an exact just octave. Therefore, when editing
// the sizes of whole or half steps, update the other to make this true.
function updateEqualHalf() {
    const divisions = document.getElementById("equalDivisions").valueAsNumber;
    const whole = document.getElementById("equalWholeStep").valueAsNumber;
    document.getElementById("equalHalfStep").value = (divisions - whole * 5) / 2;
}

function updateEqualWhole() {
    const divisions = document.getElementById("equalDivisions").valueAsNumber;
    const half = document.getElementById("equalHalfStep").valueAsNumber;
    document.getElementById("equalWholeStep").value = (divisions - half * 2) / 5;
}

function updateRatioToCents(ratioInput, centsId) {
    const centsInput = document.getElementById(centsId);
    centsInput.value = 1200 * Math.log2(ratioInput.valueAsNumber);
}

function updateCentsToRatio(centsInput, ratioId) {
    const ratioInput = document.getElementById(ratioId);
    ratioInput.value = Math.pow(2, centsInput.valueAsNumber / 1200);
}
</script>
<style>
#keyboard text {
    fill: currentcolor;
    text-anchor: middle;
    font-size: 0.5px;
    pointer-events: none;
    user-select: none;
}
#keyboard text.accidental {
    fill: #BCBCBC55;
}
#keyboard polygon.hex {
    stroke: #BCBCBC99;
    fill: #BCBCBC22;
    stroke-width: 0.1;
}
#keyboard polygon.hex.active {
    stroke: currentcolor;
}
#keyboard polygon.hex.a440 {
    fill: #BCBCBC44;
}

form {
    margin: 2em;
}
fieldset {
    padding: 0.2em;
}
form {
    line-height: 1.5lh;
}
label {
    display: inline-block;
}
label.flex {
    display: inline-flex;
    align-items: center;
}
#equalDivisions, #equalWholeStep, #equalHalfStep {
    width: 3em;
}
#basePitch {
    width: 4em;
}
#wholeStepCents, #halfStepCents {
    width: 6em;
}
.tooltip {
    display: inline-block;
    vertical-align: top;
    position: relative;
    line-height: 0.6lh;
    margin: 0.4lh;
    float: right;
}
.tooltip:before {
    font-size: 0.7em;

    aspect-ratio: 1;
    border-radius: 0.5lh;
    height: 1lh;
    display: block;

    content: "i";
    background-color: #BCBCBC55;
    text-align: center;
    left: 100%;
    margin-left: auto;
    margin-right: 0;
}
.tooltip:hover:before {
    background-color: #BCBCBC99;
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
}
.tooltip > div {
    display: none;
    position: relative;
    width: fit-content;
    border: 4px solid #BCBCBC99;
    top: 100%;
    right: 0;
    padding: 0.4lh;
}
.tooltip:hover > div {
    display: block;
}
</style>
</head>
<body>
<p>Press keys to play! If a key gets stuck, hit it again or hit <button type="button" onclick="endAll();">Escape</button> to end all notes. Hold Shift to soften notes and Space to sustain.

<div id="keyboard"></div>
<form id="keyboardForm">
<label class="flex">Key Size: <input id="keysize" type="range" min="-6" max="-1.5" step="any" value="-3.6" oninput="updateKeyboard();"></label>
<br>
Show:
<label><input type="radio" name="labelMode" value="none" oninput="updateKeyboard();">No labels</label>
<label><input type="radio" name="labelMode" value="naturals" oninput="updateKeyboard();">Naturals</label>
<label><input type="radio" name="labelMode" value="accidentals" oninput="updateKeyboard();" checked>Naturals and Accidentals</label>
</form>

<form id="voicingForm">
Voicing:
<fieldset>
<label><input type="radio" name="voicing" value="sine" oninput="updateVoicings();">Sine Wave</label>
<label><input type="radio" name="voicing" value="square" oninput="updateVoicings();">Square Wave</label>
<label><input type="radio" name="voicing" value="sawtooth" oninput="updateVoicings();">Sawtooth Wave</label>
<label><input type="radio" name="voicing" value="triangle" oninput="updateVoicings();">Triangle Wave</label>
</fieldset>
<fieldset>
<label><input type="radio" name="voicing" value="piano" oninput="updateVoicings();">Piano</label>
<label><input type="radio" name="voicing" value="oboe" oninput="updateVoicings();">Oboe</label>
<label><input type="radio" name="voicing" value="clarinet" oninput="updateVoicings();">Clarinet</label>
<label><input type="radio" name="voicing" value="horn" oninput="updateVoicings();">Horn</label>
</fieldset>
<fieldset>
<label><input type="radio" name="voicing" value="custom-string" oninput="updateVoicings();" checked>Plucked Strings —
<label class="flex">Pluck Location: <input id="stringLocation" type="range" min="0" max="1" step="any" value="0.77" oninput="updateVoicings();"></label>
<label class="flex">Decay Time: <input id="stringDecay" type="range" min="0.01" max="1" step="any" value="0.75" oninput="updateVoicings();"></label>
</label>
</fieldset>
</form>

<form id="tuningForm">
Tuning:
<fieldset>
<div class="tooltip"><div>
Equal divisions of a just octave. See also: <a href="https://en.wikipedia.org/wiki/Equal_temperament">Equal temperament (Wikipedia)</a>, <a href="https://en.xen.wiki/w/EDO">EDO (Xenharmonic Wiki)</a>
</div></div>
<label><input type="radio" name="tuning" value="12-equal" oninput="updateTunings();" checked>12-tone equal</label>
<label><input type="radio" name="tuning" value="17-equal" oninput="updateTunings();">17-tone equal</label>
<label><input type="radio" name="tuning" value="19-equal" oninput="updateTunings();">19-tone equal</label>
<label><input type="radio" name="tuning" value="22-equal" oninput="updateTunings();">22-tone equal</label>
<label><input type="radio" name="tuning" value="31-equal" oninput="updateTunings();">31-tone equal</label>
<label><input type="radio" name="tuning" value="43-equal" oninput="updateTunings();">43-tone equal</label>
<label><input type="radio" name="tuning" value="53-equal" oninput="updateTunings();">53-tone equal</label>
<br>
<label><input type="radio" name="tuning" value="custom-equal" oninput="updateTunings();">Custom Equal —
<label>Divisions: <input type="number" id="equalDivisions" min="1" step="1" value="12" oninput="updateEqualWhole(); updateTunings();"></label>
<label>Whole step: <input type="number" id="equalWholeStep" min="1" step="1" value="2" oninput="updateEqualHalf(); updateTunings();"></label>
<label>Half step: <input type="number" id="equalHalfStep" min="1" step="1" value="1" oninput="updateEqualWhole(); updateTunings();"></label>
</label>
</fieldset>
<fieldset>
<div class="tooltip"><div>
Tunings optimizing specific intervals (octaves, harmonic sevenths, perfect fifths, and major thirds) to be as close to their just ratios as possible.
</div></div>
<label><input type="radio" name="tuning" value="pythagorean" oninput="updateTunings();">Pythagorean (just fifth/octave)</label>
<label><input type="radio" name="tuning" value="quarter-comma" oninput="updateTunings();">Quarter-comma Meantone (just third/octave)</label>
<label><input type="radio" name="tuning" value="septimal" oninput="updateTunings();">Septimal Meantone (just seventh/octave)</label>
<br>
<label><input type="radio" name="tuning" value="minimax" oninput="updateTunings();">Minimax fifth/third, just octave</label>
<label><input type="radio" name="tuning" value="minimax3" oninput="updateTunings();">Minimax fifth/third/octave</label>
<label><input type="radio" name="tuning" value="squished" oninput="updateTunings();">Just fifth/third</label>
</fieldset>
<fieldset>
<div class="tooltip"><div>
See also: <a href="https://en.xen.wiki/w/The_Riemann_zeta_function_and_tuning">The Riemann zeta function and tuning (Xenharmonic Wiki)</a>
</div></div>
<label><input type="radio" name="tuning" value="12-zeta" oninput="updateTunings();">Zeta 12-tone equal</label>
<label><input type="radio" name="tuning" value="19-zeta" oninput="updateTunings();">Zeta 19-tone equal</label>
<label><input type="radio" name="tuning" value="22-zeta" oninput="updateTunings();">Zeta 22-tone equal</label>
<label><input type="radio" name="tuning" value="31-zeta" oninput="updateTunings();">Zeta 31-tone equal</label>
<label><input type="radio" name="tuning" value="41-zeta" oninput="updateTunings();">Zeta 41-tone equal</label>
<label><input type="radio" name="tuning" value="53-zeta" oninput="updateTunings();">Zeta 53-tone equal</label>
</fieldset>
<fieldset>
<div class="tooltip"><div>
See also: <a href="https://en.wikipedia.org/wiki/Regular_diatonic_tuning">Regular diatonic tuning (Wikipedia)</a>
</div></div>
<label><input type="radio" name="tuning" value="custom" oninput="updateTunings();">Custom —
<label>Whole step: <input type="number" id="wholeStep" min="1" max="2" step="any" value="1.122462048309373" oninput="updateRatioToCents(this, 'wholeStepCents'); updateTunings();"></label>
<label>(= <input type="number" id="wholeStepCents" min="0" max="1200" step="any" value="200" oninput="updateCentsToRatio(this, 'wholeStep'); updateTunings();"> cents)</label>
<label>Half step: <input type="number" id="halfStep" min="1" max="2" step="any" value="1.0594630943592953" oninput="updateRatioToCents(this, 'halfStepCents'); updateTunings();"></label>
<label>(= <input type="number" id="halfStepCents" min="0" max="1200" step="any" value="100" oninput="updateCentsToRatio(this, 'halfStep'); updateTunings();"> cents)</label>
</label>
</fieldset>
<label>Pitch standard: <input type="number" id="basePitch" step="any" value="440" oninput="updateTunings();"></label>
</form>

<form>
Effects:
<fieldset>
<label><input type="checkbox" id="randomVolume" checked>Randomize Volume <label class="flex">(Amount: <input type="range" id="randomVolumeAmount" min="0" max="0.7" step="any" value="0.1" oninput="updateEffects();">)</label></label>
</fieldset>
</form>
</body>